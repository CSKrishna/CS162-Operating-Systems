CS 162
Project 3: Key-Value Store
Design Document


Fill in the following information:

GSI: Alex
Group Number: 10 
Orzechowski Matthew <morzechowski@berkeley.edu>
Aditya Chaturvedi <aditya2013@berkeley.edu>
Duncan McAdam <duncanmcadam@berkeley.edu>

1) Please write down any miscellaneous comments or notes for your GSI.

KVCache and KVCacheSet


2) Copy here the declaration of each new or changed `struct' or
`struct' member, global or static variable, `typedef', or
enumeration for KVCache and KVCacheSet.  Briefly identify the purpose of each.

At the moment we plan to use the data structures provided to us and cannot decide on any additional declarations.


3) How will you ensure that cache accesses are very fast while also implementing the second-chance replacement policy?

The cache accesses will be fast because they involve looking up the entry in a hash table, which is a very fast operation. In the case of a cache miss for whatever reason, the operation will take longer, but by using the second-chance replacement policy, things that are used less often will be replaced by things that have been used more recently.


Socket Server and Networking
4) Copy here the declaration of each new or changed `struct' or
`struct' member, global or static variable, `typedef', or
enumeration for networking.  Briefly identify the purpose of each.

At the moment we plan to use the data structures provided to us and cannot decide on any additional declarations. 


5) To make server_run handle multiple requests simultaneously, you will need to create new threads. However, there is a limit on the number of threads you can have running at any one time, so you cannot just fork a new thread for each incoming request. How will you achieve this?

Have an allocated thread pool struct, possibly a list, that will contribute a thread each time it is created, and when there are no more available threads, place the waiting request on the work queue to wait until a thread is available.


6) Why can you not just fork a new process for every request? What are the two failure modes when this occurs? Note that we are asking about forking new processes rather than spawning new threads (which is what is actually done in the project). 

If too many calls to fork() are called, then there may be too many processes and may crash the system or make it run too slowly. When this occurs, we can place them on a work queue to wait for other processes to finish, imposing a limit of how many processes can be ran at any given time. This, like the thread pool implementation, prevents from malicious attacks as well as too many requests in general. 


7) Describe how you might test if your socket server's server_run function was working correctly (calling the appropriate handle method of kvserver/tpcmaster).

As per socket_server.c, we could test by trying to access any server started. It will return an error if it fails, for example, to access a socket, listen to it, or create it. To test this, we could attempt to access or modify data on the server using get and put, and determine the behavior.


Single Server Key-Value Store
8) Copy here the declaration of each new or changed `struct' or
`struct' member, global or static variable, `typedef', or
enumeration for the single server kv-store.  Briefly identify the purpose of each.

At the moment we plan to use the data structures provided to us and cannot decide on any additional declarations.


9) Describe at least one end-to-end test you will add. What is the scenario you will test and how will you achieve this in the test?

One end to end test we can add is to test sending a value from one server to another server, sending it back, and then verifying that they are the same. In this way, we can test if communication both in and out of the server without data corruption or incorrect algorithms works.


Distributed Key-Value Store
10) Copy here the declaration of each new or changed `struct' or
`struct' member, global or static variable, `typedef', or
enumeration for the distributed kv-store.  Briefly identify the purpose of each.

A list of structs which stores information on two phase commits. It would store the request as well as the slave it should go to.


11) Discuss, in your own words (no copy-pasting), what you will do to handle a PUT request within TPCMaster. 

TPCMaster would poll all the relevant slaves and then based on the consensus of their responses it would abort or commit the command.


12) Explain, at a high level, how you will modify kvserver_t to allow you to handle two-phase commits. 

We shall signal all the slaves and upon receiving the go ahead from ALL of the slaves, the program then looks at the struct list with the different structs and proceeds to send those requests to the tpc slaves.


13) Explain, at a high level, how you will implement kvserver_rebuild_state. How will you deal with the situation where a COMMIT message was put into the log following a PUT or DEL request, but it was not actually committed?

The program will look for copies stored of the older stored transaction and then re initialize the SERVER. After this it will compare the last two commit messages to see whether the processes actually went through or not.


14) In this project, we did not ask you to consider that TPCMaster might ever fail. What would you need to add to handle this type of failure?

We would likely need to add a TPC_master_rebuild function that re initializes TPCMaster, then restocks cache based on the information stored in the servers and then finally compares with the log. But TPC doesn’t have a log. So, we would have to add a log to it. But that should take care of it.


15) This project is optimized for a read heavy system (since writes are so slow). How would you modify this project (while keeping all the slaves) for a write heavy system?


One way would be to improvise the TPCMaster’s cache policy to allow new writes to directly go to the slaves and then let the TPCMaster only add to cache while reading from the TPCslaves when the information is requested. 
